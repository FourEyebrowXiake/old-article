---
title: 初识动态规划
date: 2017-09-16 23:07:30
tags: 动态规划
categories: 算法与数据结构
---
# 动态规划的基本思想
动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。（这部分与分治法相似）。与分治法不同的是，适合于用动态规划求解的问题，经分解得到的子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。

通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。在实际情况中，可以用一个表记录所有已解的子问题的答案。

<!-- more -->

# 动态规划的适用情况

1. 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。

2.  无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。

3.  子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。


问题具有最优子结构性质，我们才能写出最优解的递归方程；具有重叠子问题特性，我们才能通过避免重复计算来减少运行时间。

综上所述，动态规划的关键是 —— **记忆**，空间换时间，不重复求解，从较小问题解逐步决策，构造较大问题的解。

# 实例

## 斐波那契数列
只用递归来实现：
```Javascript
var fibonacci = function(n) {
	return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
}
```
这种实现不会记录先前操作的结果，每次求值都会进行无谓的重复运算。通过给它添加记忆，来优化它的时间复杂度:
```Javascript
var fibonacci = function () {
	var memo = [1, 2];
	var fib = function (n) {
		var res = memor[n];
		if(typeof res !== 'number') {
			res = fib(n-1) + fib(n-2);
			memo[n] = res;
		}
		return res;
	};
	return fib;
}();
```
通过创建一个名为memo的数组，来保存子问题的结果。memo保存在闭包中。当函数调用时，就会首先检查memo数组，如果已经存在，就直接返回结果。

总之，这个例子很好的说明了动态规划的关键，即用空间换时间。

## 01背包
01背包是动态规划中比较简单的一个问题。理解它，能清楚动态规划两个重要概念：状态和状态转移方程。

假设编号分别为a,b,c,d,e的五件物品，重量分别是2,2,6,5,4，价值分别是6,3,5,4,6，现在有一个承重为10的背包，如何装入物品具有最大价值？

### 思路分析
首先我们来找状态。动态规划的一个重要思路就是把大问题分解成小问题。小问题除了规模更小，本质上还是相同的问题。我们可以从承重为0的背包开始，再逐渐增加到承重为10的背包。具体情况，结合下图讲解：

![](/images/初识动态规划/1.png)

当背包的体积为2，行数为2时，求的是前两个物品a,b装入背包里能达到的最大值。当背包的体积为8，行数为5时，求的是前5个物品装入背包能达到的最大值。有没有发现，以上句子都是一个句式。形式化的表示它们，定义d(i,j)为前i 个物品装到剩余体积为j的背包里能达到的最大值。那么上面两句即为：d(2,2)和d(5,8)。这样看是不是简洁多了。这两个符号就是我们要找的状态，即**状态d(i,j)为前i 个物品装到剩余体积为j的背包里能达到的最大值。**

上面那么多的文字，用一句话概括就是：根据子问题定义状态！你找到子问题， 状态也就浮出水面了。而我们最终要求解的最大价值即为d(n, C)：前n个物品 （0,1,2…,n-1）装入剩余容量为C的背包中的最大价值。状态好不容易找到了， 状态转移方程呢？顾名思义，状态转移方程就是描述状态是怎么转移的方程（好废话！）。

要明白状态转移方程，你要明白上面的表格是这么填的。随便挑一个表格(a，9)，此时背包容量为9，可以选abcde五种物品，我们要找出容量的最大值，对待每个物品的具体策略是放入物品a和不放入物品a这两种情况：
- 情况a: 假如放入物品a, 则背包容量变为9-2=7，还剩b,c,d,e四种物品。所以该情况下的最大值 = (b,7) + 物品a的价值6，即9+6。
- 情况b: 假如不放入物品a, 背包容量不变为9，还剩b,c,d,e四种物品。所以该情况下的最大值 = (b, 9)，即10。

所以现在(a, 9) = max( (b,7)+6, b(9) ) = max(9+6，10) = 15。max( (b,7)+6, b(9) )就是状态转移方程的具体体现。

#### 代码实现
```Javascript
function packageMaxValue(weight, value, size) {
	// 省略参数合法性校验
    let bagMatrix = []
    for(let w = 0; w <= size; w++) {//size是背包的大小
        // js不能直接创建二维数组，所以在此初始化数组
        bagMatrix[w] = []
        for (let j = 0; j < 5; j++) {
            // 背包的容量为0，那么一个东西也装不下，此时的值肯定也是为0
            if(w === 0) {
                bagMatrix[w][j] = 0
                continue
            }
            // 背包的容量小于物品j的重量，那么就没有上述情况a了
            if(w < weight[j]){
                bagMatrix[w][j] = bagMatrix[w][j-1] || 0
                continue
            }
            bagMatrix[w][j] = Math.max((bagMatrix[w-weight[j]][j-1] || 0) + value[j], bagMatrix[w][j-1] || 0)
        }
    }
    return bagMatrix
}
```
参考链接：
- [动态规划之背包问题（一）
](http://www.hawstein.com/posts/dp-knapsack.html)
- [js实现01背包问题](https://segmentfault.com/a/1190000006082676)
